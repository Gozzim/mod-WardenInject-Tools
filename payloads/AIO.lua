assert(not AIO, 'AIO is already loaded. Possibly different versions!') local AIO_ENABLE_DEBUG_MSGS = false local AIO_ENABLE_PCALL = true local AIO_ENABLE_TRACEBACK = false local AIO_ENABLE_MSGPRINT = false local AIO_TIMEOUT_INSTRUCTIONCOUNT = 1e8 local AIO_MSG_CACHE_SPACE = 5e5 local AIO_MSG_CACHE_TIME = 15*1000 local AIO_MSG_CACHE_DELAY = 5*1000 local AIO_UI_INIT_DELAY = 5*1000 local AIO_MSG_COMPRESS = true local AIO_CODE_OBFUSCATE = true local AIO_ERROR_LOG = false local assert = assert local type = type local tostring = tostring local pairs = pairs local ipairs = ipairs local ssub = string.sub local match = string.match local ceil = ceil or math.ceil local floor = floor or math.floor local sbyte = strbyte or string.byte local schar = string.char local tconcat = table.concat local select = select local pcall = pcall local xpcall = xpcall loadstring = loadstring or load unpack = unpack or table.unpack local AIO_GetTime = os and os.time or function() return GetTime()*1000 end local AIO_GetTimeDiff = os and os.difftime or function(_now, _then) return _now-_then end local AIO_SERVER = false local AIO_VERSION = 1.74 local AIO_ShortMsg = schar(1)..schar(1) local AIO_Compressed = 'C' local AIO_Uncompressed = 'U' local AIO_Prefix = 'AIO' AIO_Prefix = ssub((AIO_Prefix), 1, 16) local AIO_ServerPrefix = ssub(('S'..AIO_Prefix), 1, 16) local AIO_ClientPrefix = ssub(('C'..AIO_Prefix), 1, 16) assert(#AIO_ServerPrefix == #AIO_ClientPrefix) local AIO_MsgLen = 255 -1 -#AIO_ServerPrefix -#AIO_ShortMsg local MSG_MIN = 1 local MSG_MAX = 2^16-767 AIO = { 	unpack = unpack, } local AIO = AIO local AIO_SAVEDFRAMES = {} local AIO_SAVEDVARS = {} local AIO_SAVEDVARSCHAR = {} local AIO_INITED = false local AIO_HANDLERS = {} local AIO_INITHOOKS = {} local AIO_BLOCKHANDLES = {} local AIO_ADDONSORDER = {} local NewQueue = NewQueue or require('queue') local Smallfolk = Smallfolk or require('smallfolk') local lualzw = lualzw or require('lualzw') local LibWindow = LibStub('LibWindow-1.1') function AIO.GetVersion() return AIO_VERSION end local function AIO_16tostring(uint16) assert(uint16 <= 2^16-767, 'Too high value') assert(uint16 >= 0, 'Negative value') local high = floor(uint16 / 254) local l = high +1 local r = uint16 - high * 254 +1 return schar(l)..schar(r) end local function AIO_stringto16(str) local l = sbyte(ssub(str, 1,1)) -1 local r = sbyte(ssub(str, 2,2)) -1 local val = l*254 + r assert(val <= 2^16-767, 'Too high value') assert(val >= 0, 'Negative value') return val end function AIO_RESET() AIO_SAVEDVARS = nil AIO_SAVEDVARSCHAR = nil AIO_sv_Addons = nil AIO_SAVEDFRAMES = {} end function AIO_debug(...) if AIO_ENABLE_DEBUG_MSGS then print('AIO:', ...) end end local function AIO_extractN(...) return select('#', ...), ... end local function AIO_pcall(f, ...) assert(type(f) == 'function') if not AIO_ENABLE_PCALL then return f(...) end local data = {AIO_extractN(pcall(f, ...))} if not data[2] then if AIO_ERROR_LOG then AIO.Handle('AIO', 'Error', data[3]) end if AIO_ENABLE_TRACEBACK then _ERRORMESSAGE(data[3]) else print(data[3]) end return end return unpack(data, 3, data[1]+1) end local function AIO_ReadFile(path) AIO_debug('Reading a file') assert(type(path) == 'string', '#1 string expected') local f = assert(io.open(path, 'rb')) local str = f:read('*all') f:close() return str end local plrdata = {} local removeque = NewQueue() local function RemoveData(guid, msgid) local pdata = plrdata[guid] if pdata then if msgid then local data = pdata[msgid] if data then pdata[msgid] = nil pdata.ramque:gettable()[data.ramquepos] = nil removeque:gettable()[data.remquepos] = nil end else local que = pdata.ramque:gettable() local l, r = pdata.ramque:getrange() for i = l, r do if que[i] then removeque:gettable()[que[i].remquepos] = nil end end plrdata[guid] = nil end end end local function ProcessRemoveQue() if removeque:empty() then return end local now = AIO_GetTime() local l, r = removeque:getrange() for i = l, r do local v = removeque:popleft() if v then if AIO_GetTimeDiff(now, v.stamp) < AIO_MSG_CACHE_TIME then AIO_debug('removing outdated incomplete message') removeque:pushleft(v) break end RemoveData(v.guid, v.id) end end end local frame = CreateFrame('Frame') local timer = AIO_MSG_CACHE_DELAY local function ONUPDATE(self, diff) if timer > diff then timer = timer - diff else ProcessRemoveQue() timer = AIO_MSG_CACHE_DELAY end end frame:SetScript('OnUpdate', ONUPDATE) local function AIO_SendAddonMessage(msg, player) SendAddonMessage(AIO_ClientPrefix, msg, 'WHISPER', UnitName('player')) end local function AIO_Send(msg, player, ...) assert(type(msg) == 'string', '#1 string expected') assert(not AIO_SERVER or type(player) == 'userdata', '#2 player expected') AIO_debug('Sending message length:', #msg) if AIO_ENABLE_MSGPRINT then print('sent:', msg) end if #msg <= AIO_MsgLen then AIO_SendAddonMessage(AIO_ShortMsg..msg, player) else local guid = 1 if not plrdata[guid] then plrdata[guid] = { stored = 0, ramque = NewQueue(), MSG_GUID = MSG_MIN, } end local pdata = plrdata[guid] local msglen = (AIO_MsgLen-4) local parts = ceil(#msg / msglen) local header = AIO_16tostring(pdata.MSG_GUID)..AIO_16tostring(parts) if pdata.MSG_GUID >= MSG_MAX then pdata.MSG_GUID = MSG_MIN else pdata.MSG_GUID = pdata.MSG_GUID+1 end for i = 1, parts do AIO_SendAddonMessage(header..AIO_16tostring(i)..ssub(msg, ((i-1)*msglen)+1, (i*msglen)), player) end end if ... then for i = 1, select('#',...) do AIO_Send(msg, select(i, ...)) end end end local msgmt = {} function msgmt.__index(tbl, key) return msgmt[key] end function msgmt:Add(Name, ...) assert(Name, '#1 Block must have name') self.params[#self.params+1] = {select('#', ...), Name, ...} self.assemble = true return self end function msgmt:Append(msg2) assert(type(msg2) == 'table', '#1 table expected') for i = 1, #msg2.params do assert(type(msg2.params[i]) == 'table', '#1['..i..'] table expected') self.params[#self.params+1] = msg2.params[i] end self.assemble = true return self end function msgmt:Assemble() if not self.assemble then return self end self.MSG = Smallfolk.dumps(self.params) self.assemble = false return self end function msgmt:Send(player, ...) assert(not AIO_SERVER or player, '#1 player is nil') AIO_Send(self:ToString(), player, ...) return self end function msgmt:Clear() for i = 1, #self.params do self.params[i] = nil end self.MSG = nil self.assemble = false return self end function msgmt:ToString() return self:Assemble().MSG end function msgmt:HasMsg() return #self.params > 0 end function AIO.Msg() local msg = {params = {}, MSG = nil, assemble = false} setmetatable(msg, msgmt) return msg end local preinitblocks = {} local function AIO_HandleBlock(player, data, skipstored) local HandleName = data[2] assert(HandleName, 'Invalid handle, no handle name') if not AIO_INITED and (HandleName ~= 'AIO' or data[3] ~= 'Init') then preinitblocks[#preinitblocks+1] = data AIO_debug('Received block before Init:', HandleName, data[1], data[3]) return end local handledata = AIO_BLOCKHANDLES[HandleName] if not handledata then error('Unknown AIO block handle: '..tostring(HandleName)) end handledata(player, unpack(data, 3, data[1]+2)) if not skipstored and AIO_INITED and HandleName == 'AIO' and data[3] == 'Init' then for i = 1, #preinitblocks do AIO_HandleBlock(player, preinitblocks[i], true) preinitblocks[i] = nil end end end local curmsg = '' local function AIO_Timeout() error(string.format('AIO Timeout. Your code ran over %s instructions with message:%s', ''..AIO_TIMEOUT_INSTRUCTIONCOUNT..'', (curmsg or 'nil'))) end local function _AIO_ParseBlocks(msg, player) AIO_debug('Received messagelength:', #msg) if AIO_ENABLE_MSGPRINT then print('received:', msg) end local data = AIO_pcall(Smallfolk.loads, msg, #msg) if not data or type(data) ~= 'table' then AIO_debug('Received invalid message - data not a table') return end for i = 1, #data do AIO_pcall(AIO_HandleBlock, player, data[i]) end end local function AIO_ParseBlocks(msg, player) AIO_pcall(_AIO_ParseBlocks, msg, player) end local function _AIO_HandleIncomingMsg(msg, player) local msgid = ssub(msg, 1,2) if msgid == AIO_ShortMsg then AIO_ParseBlocks(ssub(msg, 3), player) return end if #msg < 3*2 then return end local messageId = AIO_stringto16(msgid) local parts = AIO_stringto16(ssub(msg, 3,4)) local partId = AIO_stringto16(ssub(msg, 5,6)) if partId <= 0 or partId > parts then error('received long message with invalid amount of parts. id, parts: '..partId..' '..parts) return end msg = ssub(msg, 7) local guid = 1 if not plrdata[guid] then plrdata[guid] = { stored = 0, ramque = NewQueue(), MSG_GUID = MSG_MIN, } end local pdata = plrdata[guid] pdata[messageId] = pdata[messageId] or {} local data = pdata[messageId] if not data.parts or data.parts.n ~= parts then if data.parts then for i = 0, data.parts.n do data.parts[i] = nil end end data.guid = guid data.parts = {n=parts} data.id = messageId data.stamp = AIO_GetTime() data.remquepos = removeque:pushright(data) data.ramquepos = pdata.ramque:pushright(data) end data.parts[partId] = msg pdata.stored = pdata.stored + #msg if #data.parts == data.parts.n then local cat = tconcat(data.parts) RemoveData(guid, messageId) AIO_ParseBlocks(cat, player) end end local function AIO_HandleIncomingMsg(msg, player) AIO_pcall(_AIO_HandleIncomingMsg, msg, player) end  function AIO.RegisterEvent(name, func) assert(name ~= nil, 'name of the registered event expected not nil') assert(type(func) == 'function', 'callback function must be a function') assert(not AIO_BLOCKHANDLES[name], 'an event is already registered for the name: '..name) AIO_BLOCKHANDLES[name] = func end  function AIO.AddHandlers(name, handlertable) assert(name ~= nil, '#1 expected not nil') assert(type(handlertable) == 'table', '#2 a table expected')  for k,v in pairs(handlertable) do assert(type(v) == 'function', '#2 a table of functions expected, found a '..type(v)..' value') end  local function handler(player, key, ...) if key and handlertable[key] then handlertable[key](player, ...) end end AIO.RegisterEvent(name, handler) return handlertable end  function AIO.AddAddon(path, name) end  function AIO.Handle(name, handlername, ...) assert(name ~= nil, '#1 expected not nil') return AIO.Msg():Add(name, handlername, ...):Send() end  function AIO.AddSavedVar(key) assert(key ~= nil, '#1 table key expected') AIO_SAVEDVARS[key] = true end  function AIO.AddSavedVarChar(key) assert(key ~= nil, '#1 table key expected') AIO_SAVEDVARSCHAR[key] = true end  AIO_FRAMEPOSITIONS = AIO_FRAMEPOSITIONS or {} AIO.AddSavedVar('AIO_FRAMEPOSITIONS') AIO_FRAMEPOSITIONSCHAR = AIO_FRAMEPOSITIONSCHAR or {} AIO.AddSavedVarChar('AIO_FRAMEPOSITIONSCHAR') function AIO.SavePosition(frame, char) assert(frame:GetName(), 'Called AIO.SavePosition on a nameless frame') local store = char and AIO_FRAMEPOSITIONSCHAR or AIO_FRAMEPOSITIONS if not store[frame:GetName()] then store[frame:GetName()] = {} end LibWindow.RegisterConfig(frame, store[frame:GetName()]) LibWindow.RestorePosition(frame) LibWindow.SavePosition(frame) table.insert(AIO_SAVEDFRAMES, frame) end local function ONADDONMSG(self, event, prefix, msg, Type, sender) if prefix == AIO_ServerPrefix then if event == 'CHAT_MSG_ADDON' and sender == UnitName('player') then AIO_HandleIncomingMsg(msg, sender) end end end local MsgReceiver = CreateFrame('Frame') MsgReceiver:RegisterEvent('CHAT_MSG_ADDON') MsgReceiver:SetScript('OnEvent', ONADDONMSG) local function RunAddon(name) local code = AIO_sv_Addons[name] and AIO_sv_Addons[name].code assert(code, 'Addon doesnt exist') local compression, compressedcode = ssub(code, 1, 1), ssub(code, 2) if compression == AIO_Compressed then compressedcode = assert(lualzw.decompress(compressedcode)) end assert(loadstring(compressedcode, name))() end function AIO_HANDLERS.Init(player, version, N, addons, cached) if(AIO_VERSION ~= version) then AIO_INITED = true AIO_HandleBlock = function() end print('You have AIO version '..AIO_VERSION..' and the server uses '..(version or 'nil')..'. Get the same version') return end assert(type(N) == 'number') assert(type(addons) == 'table') assert(type(cached) == 'table') local validAddons = {} for i = 1, N do local name if addons[i] then name = addons[i].name AIO_sv_Addons[name] = addons[i] validAddons[name] = true elseif cached[i] then name = cached[i] validAddons[name] = true else error('Unexpected behavior, try /aio reset') end AIO_pcall(RunAddon, name) end local invalidAddons = {} for name, data in pairs(AIO_sv_Addons) do if not validAddons[name] then invalidAddons[#invalidAddons+1] = name end end for i = 1, #invalidAddons do local inv = invalidAddons[i] AIO_sv_Addons[inv] = nil end AIO_INITED = true print('Initialized AIO version '..AIO_VERSION..'. Type `/aio help` for commands') end function AIO_HANDLERS.ForceReload(player) local frame = CreateFrame('BUTTON') frame:SetToplevel(true) frame:SetFrameStrata('TOOLTIP') frame:SetFrameLevel(100) frame:SetAllPoints(WorldFrame) frame:SetScript('OnClick', ReloadUI) print('AIO: Force reloading UI') message('AIO: Force reloading UI') end function AIO_HANDLERS.ForceReset(player) AIO_RESET() AIO_HANDLERS.ForceReload(player) end local frame = CreateFrame('FRAME') frame:RegisterEvent('PLAYER_LOGOUT') function frame:OnEvent(event, addon) if event == 'ADDON_LOADED' and addon == 'AIO_Client' then local _,_,_, tocversion = GetBuildInfo() if tocversion and tocversion >= 40100 and RegisterAddonMessagePrefix then RegisterAddonMessagePrefix('C'..AIO_Prefix) end if type(AIO_sv) ~= 'table' then AIO_sv = {} end if type(AIO_sv_char) ~= 'table' then AIO_sv_char = {} end if type(AIO_sv_Addons) ~= 'table' then AIO_sv_Addons = {} end for k,v in pairs(AIO_sv) do if _G[k] then AIO_debug('Overwriting global var _G['..k..'] with a saved var') end _G[k] = v end for k,v in pairs(AIO_sv_char) do if _G[k] then AIO_debug('Overwriting global var _G['..k..'] with a saved character var') end _G[k] = v end local rem = {} local addons = {} for name, data in pairs(AIO_sv_Addons) do if type(name) ~= 'string' or type(data) ~= 'table' or type(data.crc) ~= 'number' or type(data.code) ~= 'string' then table.insert(rem, name) else addons[name] = data.crc end end for _,name in ipairs(rem) do AIO_sv_Addons[name] = nil end local initmsg = AIO.Msg():Add('AIO', 'Init', AIO_VERSION, addons) local reset = 1 local timer = reset local function ONUPDATE(self, diff) if AIO_INITED then self:SetScript('OnUpdate', nil) initmsg = nil reset = nil timer = nil return end if timer < diff then initmsg:Send() timer = reset reset = reset * 1.5 else timer = timer - diff end end frame:SetScript('OnUpdate', ONUPDATE) elseif event == 'PLAYER_LOGOUT' then AIO_sv = {} for key,_ in pairs(AIO_SAVEDVARS or {}) do AIO_sv[key] = _G[key] end AIO_sv_char = {} for key,_ in pairs(AIO_SAVEDVARSCHAR or {}) do AIO_sv_char[key] = _G[key] end for k,v in ipairs(AIO_SAVEDFRAMES or {}) do LibWindow.SavePosition(v) end end end frame:SetScript('OnEvent', frame.OnEvent) AIO.AddHandlers('AIO', AIO_HANDLERS) local cmds = {} local helps = {} local function pprint(player, ...) if player then player:SendBroadcastMessage(tconcat({...}, ' ')) else print(...) end end SLASH_AIO1 = '/aio' function SlashCmdList.AIO(msg) local msg = msg:lower() if msg and msg ~= '' then for k,v in pairs(cmds) do if k:find(msg, 1, true) == 1 then v() return end end end print('Unknown command /aio '..tostring(msg)) cmds.help() end helps.help = 'prints this list' function cmds.help(player) pprint(player, 'Available commands:') for k,v in pairs(cmds) do pprint(player, '/aio '..k..' - '..(helps[k] or 'no info')) end end helps.reset = 'resets local AIO cache - clears saved addons and their saved variables and reloads the UI' function cmds.reset() AIO_RESET() ReloadUI() end helps.trace = 'toggles using debug.traceback or _ERRORMESSAGE' function cmds.trace(player) AIO_ENABLE_TRACEBACK = not AIO_ENABLE_TRACEBACK pprint(player, 'using trace is now', AIO_ENABLE_TRACEBACK and 'on' or 'off') end helps.debug = 'toggles showing of debug messages' function cmds.debug(player) AIO_ENABLE_DEBUG_MSGS = not AIO_ENABLE_DEBUG_MSGS pprint(player, 'showing debug messages is now', AIO_ENABLE_DEBUG_MSGS and 'on' or 'off') end helps.pcall = 'toggles using pcall' function cmds.pcall(player) AIO_ENABLE_PCALL = not AIO_ENABLE_PCALL pprint(player, 'using pcall is now', AIO_ENABLE_PCALL and 'on' or 'off') end helps.printio = 'toggles printing all sent and received messages' function cmds.printio(player) AIO_ENABLE_MSGPRINT = not AIO_ENABLE_MSGPRINT pprint(player, 'printing IO is now', AIO_ENABLE_MSGPRINT and 'on' or 'off') end frame:OnEvent('ADDON_LOADED', 'AIO_Client') return AIO